#!/usr/bin/env node
const { program }    = require('commander');
const chalk          = require('chalk');
const esbuild        = require('esbuild');
const os             = require('os');
const fs             = require('fs');
const updateNotifier = require('update-notifier');
const { DateTime }   = require('luxon');
const externals      = require('./externals');
const packageJSON    = require('./package.json');

program
  .version(packageJSON.version)
  .argument('<input_file>', 'Original file to make build, can be a javascript or typescript file')
  .argument('[output_file]', '[optional] Destination name')
  .option('-F, --force', 'it will not ignore the modules that already exist on TagoIO context', false)
  .option('-rb, --removeBanner', 'Remove banner on output file', false)
  .option('-ob, --obfuscate', 'Make the output file hard to understand', false)
  .option('-w, --watch', 'Enabling watch mode on Analysis Build, it\'s listen for changes on the file system and to rebuild whenever a file changes', false)
  .option('--tsconfig', 'Generate a tsconfig.json file on current folder');

program.addHelpText('before', `TagoIO Builder V${packageJSON.version} (https://git.io/JJ8Si)\n`);

const options = program.parse(process.argv).opts();
const files = program.parse(process.argv).args;

const notifier = updateNotifier({ pkg: packageJSON });
notifier.notify({
  defer: false,
  isGlobal: true,
  boxenOptions: {
    padding: 1,
    margin: 1,
    align: 'center',
    borderColor: '#347AB7',
    borderStyle: 'bold',
  },
});

const currentFolder = process.cwd();

if (options.tsconfig) {
  const tsFile = fs.readFileSync(`${__dirname}/tsconfig.json`, 'utf-8');
  fs.writeFileSync(`${currentFolder}/tsconfig.json`, tsFile);
  process.exit(0);
}

const inputFile = String(files[0]);
const outputFile = files[1] || `${inputFile.replace(/.ts|.js/g, '')}.tago-io.js`;

const bannerMessage = `/*
 * TagoIO (https://tago.io/)
 * TagoIO Builder V${packageJSON.version} (https://git.io/JJ8Si)
 * -------------------
 * Generated by     :: ${os.userInfo().username ? os.userInfo().username : 'Unknown'}
 * Generated at     :: ${DateTime.utc().toFormat('ffff')}
 * Machine          :: ${os.hostname()} <${os.platform()}> - Node.js ${process.version}
 * Origin file      :: ${inputFile} <${inputFile.endsWith('.ts') ? 'Typescript' : 'Javascript'}>
 * Destination file :: ${outputFile}
 * -------------------
*/
`;

console.info(chalk.green(bannerMessage), '\n');

async function build() {
  /**
  * @type {esbuild.BuildOptions}
  */
  const buildConfig = {
    platform: 'node',
    target: 'es2020',
    absWorkingDir: currentFolder,
    entryPoints: [`./${inputFile}`],
    bundle: true,
    outfile: outputFile,
    minify: options.obfuscate || false,
    external: externals(options.force)
  };

  if (options.watch) {
    buildConfig.watch = {
      onRebuild(error) {
        if (error) {
          console.info(chalk.redBright(`${DateTime.local().toFormat('tt')} - Error on build.`));
        } else {
          console.info(chalk.greenBright(`${DateTime.local().toFormat('tt')} - Rebuild with success.`));
        }
      },
    };
  }

  if (options.removeBanner === false) {
    buildConfig.banner = {
      js: bannerMessage,
    };
  }

  let tsconfigFile = `${currentFolder}/tsconfig.json`;
  if (!fs.existsSync(tsconfigFile)) {
    tsconfigFile = `${__dirname}/tsconfig.json`;
    console.info('Using analysis-builder tsconfig.json\n');
  } else {
    console.info('Using custom tsconfig.json\n');
  }
  buildConfig.tsconfig = tsconfigFile;

  try {
    console.info(chalk.yellow('Building... -It may take a while-'));
    await esbuild.build(buildConfig);
    console.info(chalk.greenBright(`\nAnalysis file was saved at: ./${outputFile}\n`));
    if (options.watch) {
      console.info(chalk.bgMagenta.white('*** Watch Mode activated, looking for changes... (CTRL+C to exit) ***\n'));
    }
  } catch (error) {
    console.info(chalk.red('Error on build, aborted.'));
  }
}

build();
